datasource db {
  provider          = "postgresql"
  url               = env("POSTGRES_PRISMA_URL") // uses connection pooling
  directUrl         = env("POSTGRES_PRISMA_URL_NON_POOLING") // uses a direct connection
  shadowDatabaseUrl = env("POSTGRES_PRISMA_SHADOW_URL") // used for migrations
}

generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["relationJoins", "prismaSchemaFolder"]
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model User {
  id             String     @id @default(cuid())
  name           String?
  email          String?    @unique
  emailVerified  DateTime?
  image          String?
  createdAt      DateTime   @default(now())
  accounts       Account[]
  sessions       Session[]
  documents      Document[]
  teams          UserTeam[]
  domains        Domain[]
  chats          Chat[]
  contactId      String?
  plan           String     @default("free")
  stripeId       String?    @unique // Stripe subscription / customer ID
  subscriptionId String?    @unique // Stripe subscription ID
  startsAt       DateTime? // Stripe subscription start date
  endsAt         DateTime? // Stripe subscription end date

  restrictedTokens RestrictedToken[]

  // conversation
  participatedConversations ConversationParticipant[]
  messages                  Message[]

  // FAQ system
  publishedFaqItems DataroomFaqItem[]
  createdAnnotations DocumentAnnotation[] // Annotations created by this user

  installedIntegrations InstalledIntegration[]
}

model Brand {
  id          String  @id @default(cuid())
  logo        String? // This should be a reference to where the file is stored (S3, Google Cloud Storage, etc.)
  brandColor  String? // This should be a reference to the brand color
  accentColor String? // This should be a reference to the accent color
  teamId      String  @unique
  team        Team    @relation(fields: [teamId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

model Domain {
  id          String   @id @default(cuid())
  slug        String   @unique
  user        User?    @relation(fields: [userId], references: [id], onDelete: SetNull)
  userId      String?
  teamId      String
  Team        Team     @relation(fields: [teamId], references: [id], onDelete: Cascade)
  verified    Boolean  @default(false) // Whether the domain has been verified
  isDefault   Boolean  @default(false) // Whether the domain is the primary domain
  lastChecked DateTime @default(now())
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  links       Link[] // links associated with this domain

  @@index([userId])
  @@index([teamId])
}

model View {
  id                  String               @id @default(cuid())
  link                Link                 @relation(fields: [linkId], references: [id])
  linkId              String
  document            Document?            @relation(fields: [documentId], references: [id], onDelete: Cascade)
  documentId          String?
  dataroom            Dataroom?            @relation(fields: [dataroomId], references: [id], onDelete: Cascade)
  dataroomId          String?
  dataroomViewId      String? // This is the view ID from the dataroom
  viewerEmail         String? // Email of the viewer if known
  viewerName          String? // Name of the viewer if known
  verified            Boolean              @default(false) // Whether the viewer email has been verified
  viewedAt            DateTime             @default(now())
  downloadedAt        DateTime? // This is the time the document was downloaded
  reactions           Reaction[]
  viewType            ViewType             @default(DOCUMENT_VIEW)
  viewerId            String? // This is the viewer ID from the dataroom
  viewer              Viewer?              @relation(fields: [viewerId], references: [id], onDelete: Cascade)
  groupId             String? // This is the group ID from the dataroom
  group               ViewerGroup?         @relation(fields: [groupId], references: [id], onDelete: SetNull)
  feedbackResponse    FeedbackResponse?
  agreementResponse   AgreementResponse?
  customFieldResponse CustomFieldResponse?

  isArchived Boolean @default(false) // Indicates if the view is archived and not counted in the analytics

  // conversation
  conversationViews    ConversationView[]
  messages             Message[]
  initialConversations Conversation[]     @relation("initialView")

  uploadedDocuments DocumentUpload[] // uploaded documents by this view

  teamId String?
  team   Team?   @relation(fields: [teamId], references: [id], onDelete: Cascade)

  @@index([linkId])
  @@index([documentId])
  @@index([dataroomId])
  @@index([dataroomViewId])
  @@index([viewerId])
  @@index([groupId]) // Performance optimization for groupBy queries on groupId
  @@index([teamId])
  @@index([viewedAt(sort: Desc)]) // Performance optimization for date aggregations
  @@index([viewerId, documentId]) // Performance optimization for joins with filtering
  @@index([viewerEmail]) // Performance optimization for viewer email filtering
  @@index([documentId, isArchived]) // Performance optimization for active views filtering
  @@index([documentId, viewedAt(sort: Desc)]) // Performance optimization for latest views queries
}

enum ViewType {
  DOCUMENT_VIEW
  DATAROOM_VIEW
}

model Viewer {
  id                      String    @id @default(cuid())
  email                   String
  verified                Boolean   @default(false) // Whether the viewer email has been verified
  invitedAt               DateTime? // This is the time the viewer was invited
  notificationPreferences Json? // Format: { dataroom: {"dr_123": { "enabled": false }, "dr_456": { "enabled": true } } } }

  dataroomId String?
  dataroom   Dataroom? @relation(fields: [dataroomId], references: [id], onDelete: SetNull)
  teamId     String
  team       Team      @relation(fields: [teamId], references: [id], onDelete: Cascade)

  views                     View[]
  groups                    ViewerGroupMembership[]
  participatedConversations ConversationParticipant[]
  messages                  Message[]

  uploadedDocuments DocumentUpload[] // uploaded documents by this viewer

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([teamId, email])
  @@index([teamId])
  @@index([dataroomId])
}

model Reaction {
  id         String   @id @default(cuid())
  view       View     @relation(fields: [viewId], references: [id], onDelete: Cascade)
  viewId     String
  pageNumber Int
  type       String // e.g., "like", "dislike", "love", "hate", etc.
  createdAt  DateTime @default(now())

  @@index([viewId])
  @@index([viewId, type]) // Performance optimization for reaction grouping
}

model Invitation {
  email     String
  expires   DateTime
  teamId    String
  team      Team     @relation(fields: [teamId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now())
  token     String   @unique

  @@unique([email, teamId])
}

enum EmailType {
  FIRST_DAY_DOMAIN_REMINDER_EMAIL
  FIRST_DOMAIN_INVALID_EMAIL
  SECOND_DOMAIN_INVALID_EMAIL
  FIRST_TRIAL_END_REMINDER_EMAIL
  FINAL_TRIAL_END_REMINDER_EMAIL
}

model SentEmail {
  id         String    @id @default(cuid())
  type       EmailType
  recipient  String // Email address of the recipient
  marketing  Boolean   @default(false)
  createdAt  DateTime  @default(now())
  team       Team      @relation(fields: [teamId], references: [id], onDelete: Cascade)
  teamId     String
  domainSlug String? // Domain that triggered the email. This can be nullable, representing emails not triggered by domains

  @@index([teamId])
}

model Chat {
  id            String    @id @default(cuid())
  threadId      String    @unique // This is the thread ID from OpenAI Assistant API
  user          User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId        String
  document      Document  @relation(fields: [documentId], references: [id], onDelete: Cascade)
  documentId    String
  createdAt     DateTime  @default(now())
  lastMessageAt DateTime? // This is the last time a message was sent in the thread

  @@unique([userId, documentId])
  @@unique([threadId, documentId])
  @@index([threadId])
}

model Feedback {
  id     String @id @default(cuid())
  linkId String @unique
  link   Link   @relation(fields: [linkId], references: [id], onDelete: Cascade)
  data   Json // This will store the feedback question data: {question: "What is the purpose of this document?", type: "yes/no", options: ["Yes", "No"]}

  responses FeedbackResponse[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([linkId])
}

model FeedbackResponse {
  id         String   @id @default(cuid())
  feedbackId String
  feedback   Feedback @relation(fields: [feedbackId], references: [id], onDelete: Cascade)
  data       Json // This will store the feedback question data: {question: "What is the purpose of this document?", type: "yes/no", options: ["Yes", "No"], answer: "Yes"}
  viewId     String   @unique
  view       View     @relation(fields: [viewId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([feedbackId])
  @@index([viewId])
}

model Agreement {
  id          String @id @default(cuid())
  name        String // Easily identifiable name for the agreement
  content     String // This will store the agreement content (URL or text)
  contentType String @default("LINK") // "LINK" or "TEXT" - determines how content should be displayed

  links     Link[]
  responses AgreementResponse[]

  requireName Boolean @default(true) // Optional require name field

  teamId String
  team   Team   @relation(fields: [teamId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  deletedAt DateTime?
  deletedBy String?

  @@index([teamId])
}

model AgreementResponse {
  id          String    @id @default(cuid())
  agreementId String
  agreement   Agreement @relation(fields: [agreementId], references: [id], onDelete: Cascade)
  viewId      String    @unique
  view        View      @relation(fields: [viewId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([agreementId])
  @@index([viewId])
}

model IncomingWebhook {
  id                  String    @id @default(cuid())
  externalId          String    @unique
  name                String
  secret              String? // Webhook signing secret for verification
  source              String? // Allowed source URL/domain
  actions             String? // comma separated (Eg: "documents:write,documentVersions:write")
  consecutiveFailures Int       @default(0)
  lastFailedAt        DateTime?
  disabledAt          DateTime?

  teamId String
  team   Team   @relation(fields: [teamId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([teamId])
}

model RestrictedToken {
  id         String    @id @default(cuid())
  name       String
  hashedKey  String    @unique
  partialKey String
  scopes     String? // comma separated (Eg: "documents:write,links:write")
  expires    DateTime?
  lastUsed   DateTime?
  rateLimit  Int       @default(60) // rate limit per minute

  userId String
  teamId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  team   Team   @relation(fields: [teamId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
  @@index([teamId])
}

model Webhook {
  id       String @id @default(cuid())
  pId      String @unique // public ID for the webhook
  name     String
  url      String
  secret   String // signing secret for the webhook
  triggers Json

  teamId String
  team   Team   @relation(fields: [teamId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([teamId])
}

model YearInReview {
  id            String    @id @default(cuid())
  teamId        String
  status        String    @default("pending") // pending, processing, completed, failed
  attempts      Int       @default(0)
  lastAttempted DateTime?
  error         String?

  stats Json

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([status, attempts])
  @@index([teamId])
}

enum TagType {
  LINK_TAG
  DOCUMENT_TAG
  DATAROOM_TAG
}

model Tag {
  id          String  @id @default(cuid())
  name        String
  color       String
  description String?

  teamId String
  team   Team   @relation(fields: [teamId], references: [id], onDelete: Cascade)

  items TagItem[]

  createdBy String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([teamId, name])
  @@index([teamId])
  @@index([name])
  @@index([id])
}

model TagItem {
  id       String  @id @default(cuid())
  tagId    String
  tag      Tag     @relation(fields: [tagId], references: [id], onDelete: Cascade)
  itemType TagType

  // tag can be linked to a link, document or dataroom
  linkId     String?
  link       Link?     @relation(fields: [linkId], references: [id], onDelete: Cascade)
  documentId String?
  document   Document? @relation(fields: [documentId], references: [id], onDelete: Cascade)
  dataroomId String?
  dataroom   Dataroom? @relation(fields: [dataroomId], references: [id], onDelete: Cascade)

  taggedBy  String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([tagId, linkId])
  @@index([tagId, documentId])
  @@index([tagId, dataroomId])
}
model Team {
  id           String        @id @default(cuid())
  name         String
  users        UserTeam[]
  documents    Document[]
  folders      Folder[]
  domains      Domain[]
  invitations  Invitation[]
  sentEmails   SentEmail[]
  brand        Brand?
  datarooms    Dataroom[]
  agreements   Agreement[]
  viewerGroups ViewerGroup[]
  viewers      Viewer[]

  permissionGroups  PermissionGroup[]
  linkPresets       LinkPreset[] // Link presets for the team
  incomingWebhooks  IncomingWebhook[]
  restrictedTokens  RestrictedToken[]
  webhooks          Webhook[]
  conversations     Conversation[]
  dataroomFaqItems  DataroomFaqItem[]
  uploadedDocuments DocumentUpload[]
  Tag               Tag[]
  annotations       DocumentAnnotation[] // Annotations created by team members

  installedIntegrations InstalledIntegration[]

  links Link[]
  views View[]

  plan           String    @default("free")
  stripeId       String?   @unique // Stripe customer ID
  subscriptionId String?   @unique // Stripe subscription ID
  startsAt       DateTime? // Stripe subscription start date
  endsAt         DateTime? // Stripe subscription end date
  pausedAt       DateTime? // When the subscription was paused
  pauseStartsAt  DateTime? // When the pause period starts
  pauseEndsAt    DateTime? // When the pause period ends
  cancelledAt    DateTime? // When the subscription was cancelled

  limits Json? // Plan limits // {datarooms: 1, users: 1, domains: 1, customDomainOnPro: boolean, customDomainInDataroom: boolean}

  // team settings
  enableExcelAdvancedMode Boolean @default(false) // Enable Excel advanced mode for all documents in the team

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  ignoredDomains  String[] // Domains that are ignored for the team
  globalBlockList String[] // Email and domains that are blocked for the team
}

enum Role {
  ADMIN
  MANAGER
  MEMBER
}

model UserTeam {
  role   Role   @default(MEMBER)
  status String @default("ACTIVE")
  userId String
  teamId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  team   Team   @relation(fields: [teamId], references: [id], onDelete: Cascade)

  blockedAt               DateTime? // When the user was blocked
  notificationPreferences Json? // Format: { yearInReview: { "enabled": false } }

  @@id([userId, teamId])
  @@index([userId])
  @@index([teamId])
}
model Document {
  id                   String              @id @default(cuid())
  name                 String
  description          String?
  file                 String // This should be a reference to where the file is stored (S3, Google Cloud Storage, etc.)
  originalFile         String? // This should be a reference to the original file like pptx, xlsx, etc. (S3, Google Cloud Storage, etc.)
  type                 String? // This should be a reference to the file type (pdf, sheet, etc.)
  contentType          String? // This should be the actual contentType of the file like application/pdf, application/vnd.openxmlformats-officedocument.spreadsheetml.sheet, etc.
  storageType          DocumentStorageType @default(VERCEL_BLOB)
  numPages             Int? // This should be a reference to the number of pages in the document
  owner                User?               @relation(fields: [ownerId], references: [id], onDelete: SetNull)
  teamId               String
  team                 Team                @relation(fields: [teamId], references: [id], onDelete: Cascade)
  ownerId              String? // This field holds the foreign key.
  assistantEnabled     Boolean             @default(false) // This indicates if assistant is enabled for this document
  advancedExcelEnabled Boolean             @default(false) // This indicates if advanced Excel is enabled for this document
  downloadOnly         Boolean             @default(false) // Indicates if the document is download only
  createdAt            DateTime            @default(now())
  updatedAt            DateTime            @updatedAt
  links                Link[]
  views                View[]
  versions             DocumentVersion[]
  chats                Chat[]

  folderId String? // Optional Folder ID for documents in folders
  folder   Folder? @relation(fields: [folderId], references: [id], onDelete: SetNull)

  datarooms DataroomDocument[] // Datarooms associated with this document
  tags      TagItem[]
  annotations DocumentAnnotation[] // Annotations for this document

  // upload external documents
  uploadedDocument DocumentUpload[]
  isExternalUpload Boolean          @default(false) // Indicates if the document is an external upload

  @@index([ownerId])
  @@index([teamId])
  @@index([folderId])
  @@index([teamId, folderId]) // Performance optimization for document filtering by team and folder
  @@index([teamId, name]) // Performance optimization for document search by name
}

model DocumentVersion {
  id            String              @id @default(cuid())
  versionNumber Int // e.g., 1, 2, 3 for version control
  document      Document            @relation(fields: [documentId], references: [id], onDelete: Cascade)
  documentId    String
  file          String // This should be a reference to where the file is stored (S3, Google Cloud Storage, etc.)
  originalFile  String? // This should be a reference to the original file like pptx, xlsx, etc. (S3, Google Cloud Storage, etc.)
  type          String? // This should be a reference to the file type (pdf, docx, etc.)
  contentType   String? // This should be the actual contentType of the file like application/pdf, application/vnd.openxmlformats-officedocument.spreadsheetml.sheet, etc.
  fileSize      BigInt? // This should be the size of the file in bytes
  storageType   DocumentStorageType @default(VERCEL_BLOB)
  numPages      Int? // This should be a reference to the number of pages in the document
  isPrimary     Boolean             @default(false) // Indicates if this is the primary version
  isVertical    Boolean             @default(false) // Indicates if the document is vertical (portrait) or not (landscape)
  fileId        String? // This is the file ID of the OpenAI File API
  pages         DocumentPage[]
  hasPages      Boolean             @default(false) // Indicates if the document has pages
  length        Int? // This is the length of the video in seconds
  createdAt     DateTime            @default(now())
  updatedAt     DateTime            @updatedAt

  @@unique([versionNumber, documentId])
  @@index([documentId])
  @@index([documentId, isPrimary]) // Performance optimization for primary version queries
  @@index([documentId, createdAt(sort: Desc)]) // Partial index for primary versions
  @@index([documentId, isPrimary, createdAt]) // Optimize primary version lookups with ordering
}

model DocumentPage {
  id            String              @id @default(cuid())
  version       DocumentVersion     @relation(fields: [versionId], references: [id], onDelete: Cascade)
  versionId     String
  pageNumber    Int // e.g., 1, 2, 3 for 
  embeddedLinks String[]
  pageLinks     Json? // This will store the page links data: [{href: "https://example.com", coords: "0,0,100,100"}]
  metadata      Json? // This will store the page metadata: {originalWidth: 100, origianlHeight: 100, scaledWidth: 50, scaledHeight: 50, scaleFactor: 2}
  file          String // This should be a reference to where the file / page is stored (S3, Google Cloud Storage, etc.)
  storageType   DocumentStorageType @default(VERCEL_BLOB)
  createdAt     DateTime            @default(now())
  updatedAt     DateTime            @updatedAt

  @@unique([pageNumber, versionId])
  @@index([versionId])
}

enum DocumentStorageType {
  S3_PATH
  VERCEL_BLOB
}

model Folder {
  id           String     @id @default(cuid())
  name         String
  path         String // the materialized path to the folder; starts always with "/"
  parentId     String?
  documents    Document[]
  childFolders Folder[]   @relation("SubFolders")
  parentFolder Folder?    @relation("SubFolders", fields: [parentId], references: [id], onDelete: SetNull)
  teamId       String
  team         Team       @relation(fields: [teamId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([teamId, path])
  @@index([parentId])
}

model DocumentUpload {
  id         String   @id @default(cuid())
  documentId String
  document   Document @relation(fields: [documentId], references: [id], onDelete: Cascade)
  teamId     String
  team       Team     @relation(fields: [teamId], references: [id], onDelete: Cascade)
  viewerId   String?
  viewer     Viewer?  @relation(fields: [viewerId], references: [id], onDelete: SetNull)
  viewId     String?
  view       View?    @relation(fields: [viewId], references: [id], onDelete: SetNull)
  linkId     String
  link       Link     @relation(fields: [linkId], references: [id], onDelete: Cascade)

  // Optional dataroom relations
  dataroomId         String?
  dataroom           Dataroom?         @relation(fields: [dataroomId], references: [id], onDelete: SetNull)
  dataroomDocumentId String?
  dataroomDocument   DataroomDocument? @relation(fields: [dataroomDocumentId], references: [id], onDelete: SetNull)

  // Additional metadata
  originalFilename String?
  fileSize         BigInt?
  numPages         Int?
  mimeType         String?
  uploadedAt       DateTime @default(now())

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([documentId])
  @@index([viewerId])
  @@index([viewId])
  @@index([linkId])
  @@index([teamId])
  @@index([dataroomId])
  @@index([dataroomDocumentId])
}
enum LinkType {
  DOCUMENT_LINK
  DATAROOM_LINK
}

enum LinkAudienceType {
  GENERAL
  GROUP
  TEAM
}

model Link {
  id                         String     @id @default(cuid())
  document                   Document?  @relation(fields: [documentId], references: [id], onDelete: Cascade)
  documentId                 String? // This can be nullable, representing links without documents
  dataroom                   Dataroom?  @relation(fields: [dataroomId], references: [id], onDelete: Cascade)
  dataroomId                 String? // This can be nullable, representing links without datarooms
  linkType                   LinkType   @default(DOCUMENT_LINK) // This will store the type of the link
  url                        String?    @unique
  name                       String? // Link name
  slug                       String? // Link slug for pretty URLs
  expiresAt                  DateTime? // Optional expiration date
  password                   String? // Optional password for link protection
  allowList                  String[] // Array of emails and domains allowed to view the document
  denyList                   String[] // Array of emails and domains denied to view the document
  emailProtected             Boolean    @default(true) // Optional email protection
  emailAuthenticated         Boolean    @default(false) // Optional email authentication flag
  allowDownload              Boolean?   @default(false) // Optional give user a option to allow to download the document
  isArchived                 Boolean    @default(false) // Indicates if the link is archived
  views                      View[]
  domain                     Domain?    @relation(fields: [domainId], references: [id], onDelete: SetNull)
  domainId                   String? // This can be nullable, representing links without custom domains
  domainSlug                 String? // This will store the domain's slug even if the domain is deleted
  createdAt                  DateTime   @default(now())
  updatedAt                  DateTime   @updatedAt
  enableNotification         Boolean?   @default(true) // Optional give user a option to pause/resume the notifications
  enableFeedback             Boolean?   @default(false) // Optional give user a option to enable the reactions toolbar
  enableQuestion             Boolean?   @default(false) // Optional give user a option to enable the question feedback
  enableScreenshotProtection Boolean?   @default(false) // Optional give user a option to enable the screenshot protection
  feedback                   Feedback?
  enableAgreement            Boolean?   @default(false) // Optional give user a option to enable the terms and conditions
  agreement                  Agreement? @relation(fields: [agreementId], references: [id], onDelete: SetNull)
  agreementId                String? // This can be nullable, representing links without agreements
  showBanner                 Boolean?   @default(false) // Optional give user a option to show the banner and end of document signup form
  enableWatermark            Boolean?   @default(false) // Optional give user a option to enable the watermark
  watermarkConfig            Json? // This will store the watermark configuration: {text: "Confidential", isTiled: false, color: "#000000", fontSize: 12, opacity: 0.5, rotation: 30, position: "top-right"}

  // group links
  audienceType LinkAudienceType @default(GENERAL) // This will store the audience type of the link
  groupId      String?
  group        ViewerGroup?     @relation(fields: [groupId], references: [id], onDelete: SetNull)

  // granular permissions
  permissionGroupId String?
  permissionGroup   PermissionGroup? @relation(fields: [permissionGroupId], references: [id], onDelete: SetNull)

  // custom metatags
  metaTitle           String? // This will be the meta title of the link
  metaDescription     String? // This will be the meta description of the link
  metaImage           String? // This will be the meta image of the link
  metaFavicon         String? // This will be the meta favicon of the link
  enableCustomMetatag Boolean? @default(false) // Optional give user a option to enable the custom metatag

  // conversation
  enableConversation Boolean        @default(false) // Controls if conversations are allowed on this link
  conversations      Conversation[]

  // FAQ system
  dataroomFaqItems DataroomFaqItem[]

  // upload
  enableUpload      Boolean? @default(false) // Optional give user a option to enable the upload document function
  isFileRequestOnly Boolean? @default(false) // Optional give user a option to enable the file request only
  uploadFolderId    String? // This can be nullable, indicating upload to root folder, either document folder or dataroom folder
  enableIndexFile   Boolean? @default(false)

  uploadedDocuments DocumentUpload[]

  teamId String?
  team   Team?   @relation(fields: [teamId], references: [id], onDelete: Cascade)

  customFields CustomField[]

  tags TagItem[]

  @@unique([domainSlug, slug])
  @@index([documentId])
  @@index([teamId])
  @@index([documentId, isArchived]) // Performance optimization for active links filtering
  @@index([permissionGroupId]) // Performance optimization for permission group queries
}

model LinkPreset {
  id     String  @id @default(cuid())
  name   String
  teamId String
  team   Team    @relation(fields: [teamId], references: [id], onDelete: Cascade)
  pId    String? @unique

  enableCustomMetaTag Boolean? @default(false) // Optional give user a option to enable the custom metatag
  metaTitle           String? // This will be the meta title of the link
  metaDescription     String? // This will be the meta description of the link
  metaImage           String? // This will be the meta image of the link 
  metaFavicon         String? // This will be the meta favicon of the link

  enableNotification         Boolean?  @default(false)
  emailProtected             Boolean?  @default(true)
  emailAuthenticated         Boolean?  @default(false)
  allowDownload              Boolean?  @default(false)
  enableAllowList            Boolean?  @default(false)
  allowList                  String[]
  enableDenyList             Boolean?  @default(false)
  denyList                   String[]
  expiresIn                  Int? // how many days from link creation until it expires in seconds
  enableScreenshotProtection Boolean?  @default(false)
  expiresAt                  DateTime?
  enablePassword             Boolean?  @default(false)
  password                   String?
  enableWatermark            Boolean?  @default(false)
  watermarkConfig            Json? //{text: "Confidential", isTiled: false, color: "#000000", fontSize: 12, opacity: 0.5, rotation: 30, position: "top-right"}

  enableAgreement Boolean? @default(false)
  agreementId     String?

  enableCustomFields Boolean? @default(false)
  customFields       Json? //[{type: "SHORT_TEXT", identifier: "name", label: "Name", required: true}]

  isDefault Boolean @default(false)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([teamId])
}

enum CustomFieldType {
  SHORT_TEXT
  LONG_TEXT
  NUMBER
  PHONE_NUMBER
  URL
  CHECKBOX
  SELECT
  MULTI_SELECT
}

model CustomField {
  id          String          @id @default(cuid())
  createdAt   DateTime        @default(now())
  updatedAt   DateTime        @updatedAt
  type        CustomFieldType
  identifier  String
  label       String
  placeholder String?
  required    Boolean         @default(false)
  disabled    Boolean         @default(false)
  link        Link            @relation(fields: [linkId], references: [id], onDelete: Cascade)
  linkId      String
  orderIndex  Int             @default(0)

  @@index([linkId])
}

model CustomFieldResponse {
  id        String   @id @default(cuid())
  data      Json // Store the custom field responses as a JSON object [{ "identifier": "value", "label": "value", "response:" }]
  viewId    String   @unique
  view      View     @relation(fields: [viewId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([viewId])
}
model Dataroom {
  id           String             @id @default(cuid())
  pId          String             @unique // This is the generated public ID for the dataroom dr_1234
  name         String
  description  String?
  teamId       String
  team         Team               @relation(fields: [teamId], references: [id], onDelete: Cascade)
  documents    DataroomDocument[]
  folders      DataroomFolder[]
  links        Link[]
  views        View[]
  viewers      Viewer[]
  viewerGroups ViewerGroup[]
  brand        DataroomBrand?

  permissionGroups PermissionGroup[]

  // conversation
  conversationsEnabled Boolean        @default(false)
  conversations        Conversation[]

  // FAQ system
  faqItems DataroomFaqItem[]

  // upload external documents
  uploadedDocuments DocumentUpload[]

  // tags
  tags TagItem[]

  // notification settings
  enableChangeNotifications Boolean @default(false)

  // unified permission strategy
  defaultPermissionStrategy DefaultPermissionStrategy @default(INHERIT_FROM_PARENT)

  // bulk download setting
  allowBulkDownload Boolean @default(true) // Allow bulk download of entire dataroom

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([teamId])
}

model DataroomDocument {
  id                String          @id @default(cuid())
  dataroomId        String
  dataroom          Dataroom        @relation(fields: [dataroomId], references: [id], onDelete: Cascade)
  documentId        String
  document          Document        @relation(fields: [documentId], references: [id], onDelete: Cascade)
  folderId          String?
  folder            DataroomFolder? @relation(fields: [folderId], references: [id], onDelete: SetNull)
  orderIndex        Int?
  hierarchicalIndex String? // Computed field like "1.2.3" for hierarchical display

  conversations Conversation[]

  // FAQ system
  dataroomFAQs DataroomFaqItem[]

  uploadedDocuments DocumentUpload[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([dataroomId, documentId])
  @@index([folderId])
  @@index([dataroomId, folderId, orderIndex])
  @@index([documentId])
}

model DataroomFolder {
  id                String             @id @default(cuid())
  name              String
  path              String // the materialized path to the folder; starts always with "/"
  parentId          String?
  documents         DataroomDocument[]
  childFolders      DataroomFolder[]   @relation("SubFolders")
  parentFolder      DataroomFolder?    @relation("SubFolders", fields: [parentId], references: [id], onDelete: SetNull)
  dataroomId        String
  dataroom          Dataroom           @relation(fields: [dataroomId], references: [id], onDelete: Cascade)
  orderIndex        Int?
  hierarchicalIndex String? // Computed field like "1.2" for hierarchical display

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([dataroomId, path])
  @@index([parentId])
  @@index([dataroomId, parentId, orderIndex])
}

model DataroomBrand {
  id             String   @id @default(cuid())
  logo           String? // This should be a reference to where the file is stored (S3, Google Cloud Storage, etc.)
  banner         String? // This should be a reference to where the file is stored (S3, Google Cloud Storage, etc.)
  brandColor     String? // This should be a reference to the brand color
  accentColor    String? // This should be a reference to the accent color
  welcomeMessage String? // This should be a reference to the welcome message
  dataroomId     String   @unique
  dataroom       Dataroom @relation(fields: [dataroomId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model ViewerGroup {
  id             String                      @id @default(cuid())
  name           String
  members        ViewerGroupMembership[]
  domains        String[]
  links          Link[]
  accessControls ViewerGroupAccessControls[]
  allowAll       Boolean                     @default(false)

  dataroomId String
  dataroom   Dataroom @relation(fields: [dataroomId], references: [id], onDelete: Cascade)
  teamId     String
  team       Team     @relation(fields: [teamId], references: [id], onDelete: Cascade)

  views         View[]
  conversations Conversation[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([dataroomId])
  @@index([teamId])
  @@index([dataroomId, createdAt])
}

model ViewerGroupMembership {
  id       String      @id @default(cuid())
  viewerId String
  viewer   Viewer      @relation(fields: [viewerId], references: [id], onDelete: Cascade)
  groupId  String
  group    ViewerGroup @relation(fields: [groupId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([viewerId, groupId])
  @@index([viewerId])
  @@index([groupId])
}

model ViewerGroupAccessControls {
  id      String      @id @default(cuid())
  groupId String
  group   ViewerGroup @relation(fields: [groupId], references: [id], onDelete: Cascade)

  // Access control for items (documents or dataroom items)
  itemId   String // This can be a document ID or a dataroom item ID
  itemType ItemType // Enum: DATAROOM_DOCUMENT, DATAROOM_FOLDER

  // Granular permissions
  canView     Boolean @default(true)
  canDownload Boolean @default(false)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([groupId, itemId])
  @@index([groupId])
}

enum ItemType {
  DATAROOM_DOCUMENT
  DATAROOM_FOLDER
}

enum DefaultPermissionStrategy {
  INHERIT_FROM_PARENT
  ASK_EVERY_TIME
  HIDDEN_BY_DEFAULT
}

model PermissionGroup {
  id          String  @id @default(cuid())
  name        String
  description String?

  links          Link[]
  accessControls PermissionGroupAccessControls[]

  dataroomId String
  dataroom   Dataroom @relation(fields: [dataroomId], references: [id], onDelete: Cascade)
  teamId     String
  team       Team     @relation(fields: [teamId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([dataroomId])
  @@index([teamId])
}

model PermissionGroupAccessControls {
  id      String          @id @default(cuid())
  groupId String
  group   PermissionGroup @relation(fields: [groupId], references: [id], onDelete: Cascade)

  // Access control for items (documents or dataroom items)
  itemId   String // This can be a document ID or a dataroom item ID
  itemType ItemType // Enum: DATAROOM_DOCUMENT, DATAROOM_FOLDER

  // Granular permissions
  canView             Boolean @default(true)
  canDownload         Boolean @default(false)
  canDownloadOriginal Boolean @default(false)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([groupId, itemId])
  @@index([groupId])
}
model Conversation {
  id        String  @id @default(cuid())
  title     String? // Optional title for the conversation
  isEnabled Boolean @default(true)

  // Visibility control
  visibilityMode ConversationVisibility @default(PRIVATE)

  // Core relationships
  dataroomId String
  dataroom   Dataroom @relation(fields: [dataroomId], references: [id], onDelete: Cascade)

  // Optional attachments
  dataroomDocumentId    String?
  dataroomDocument      DataroomDocument? @relation(fields: [dataroomDocumentId], references: [id], onDelete: SetNull)
  documentVersionNumber Int? // Optional document version number reference
  documentPageNumber    Int? // Optional document page number reference

  // Optional link relationship
  linkId String?
  link   Link?   @relation(fields: [linkId], references: [id], onDelete: SetNull)

  // Optional viewer group relationship
  viewerGroupId String?
  viewerGroup   ViewerGroup? @relation(fields: [viewerGroupId], references: [id], onDelete: SetNull)

  // Original view that initiated the conversation (for reference)
  initialViewId String?
  initialView   View?   @relation(name: "initialView", fields: [initialViewId], references: [id], onDelete: SetNull)

  teamId String
  team   Team   @relation(fields: [teamId], references: [id], onDelete: Cascade)

  // Track all views that accessed this conversation
  views ConversationView[]

  // Track participants including the owner
  participants ConversationParticipant[]

  // Track conversations
  messages      Message[]
  lastMessageAt DateTime? // Last message timestamp

  // Published FAQs created from this conversation
  faqItems DataroomFaqItem[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([dataroomId])
  @@index([dataroomDocumentId])
  @@index([linkId])
  @@index([teamId])
  @@index([viewerGroupId])
  @@index([initialViewId])
}

// Define conversation visibility options
enum ConversationVisibility {
  PRIVATE // Only visible to participants and team members
  PUBLIC_LINK // Visible to all viewers with access to the specific link
  PUBLIC_GROUP // Visible to all viewers in the specific group
  PUBLIC_DOCUMENT // Visible to all viewers with access to the document, across any link
  PUBLIC_DATAROOM // Visible to all viewers with access to the dataroom
}

// Define participant roles
enum ParticipantRole {
  OWNER // Created the conversation
  PARTICIPANT // Joined the conversation later
}

// Track participants in a conversation (including the owner)
model ConversationParticipant {
  id             String       @id @default(cuid())
  conversationId String
  conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)

  // Role in the conversation
  role ParticipantRole @default(PARTICIPANT)

  // Participant can be either a viewer or a user
  viewerId String?
  viewer   Viewer? @relation(fields: [viewerId], references: [id], onDelete: SetNull)
  userId   String?
  user     User?   @relation(fields: [userId], references: [id], onDelete: SetNull)

  // Notification preferences
  receiveNotifications Boolean @default(false)

  createdAt DateTime @default(now())

  @@unique([conversationId, viewerId])
  @@unique([conversationId, userId])
  @@index([conversationId])
  @@index([viewerId])
  @@index([userId])
}

model Message {
  id      String @id @default(cuid())
  content String // The actual message content

  // Conversation relationship
  conversationId String
  conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)

  // Sender information
  userId String? // Optional - for team members
  user   User?   @relation(fields: [userId], references: [id], onDelete: SetNull)

  viewerId String? // Optional - for viewers
  viewer   Viewer? @relation(fields: [viewerId], references: [id], onDelete: SetNull)

  // The specific view when this message was sent (for tracking)
  viewId String?
  view   View?   @relation(fields: [viewId], references: [id], onDelete: SetNull)

  // Tracking
  isRead Boolean @default(false)

  // FAQ relationships (reverse relations)
  faqAsQuestion DataroomFaqItem[] @relation("FAQQuestionMessage")
  faqAsAnswer   DataroomFaqItem[] @relation("FAQAnswerMessage")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([conversationId])
  @@index([userId])
  @@index([viewerId])
  @@index([viewId])
}

// Join table to track all views that accessed a conversation
model ConversationView {
  id             String       @id @default(cuid())
  conversationId String
  conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  viewId         String
  view           View         @relation(fields: [viewId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())

  @@unique([conversationId, viewId])
  @@index([conversationId])
  @@index([viewId])
}

// Published FAQ items for datarooms
model DataroomFaqItem {
  id               String  @id @default(cuid())
  title            String? // Optional title for the FAQ
  editedQuestion   String // Admin-edited version of the question
  originalQuestion String? // Original question from visitor (for reference)
  answer           String // The answer content
  description      String? // Optional context or description

  // Relationships
  dataroomId String
  dataroom   Dataroom @relation(fields: [dataroomId], references: [id], onDelete: Cascade)

  linkId String? // Optional: specific link visibility
  link   Link?   @relation(fields: [linkId], references: [id], onDelete: SetNull)

  dataroomDocumentId String? // Optional: document-specific FAQ
  dataroomDocument   DataroomDocument? @relation(fields: [dataroomDocumentId], references: [id], onDelete: SetNull)

  // Source conversation and messages (for reference and editing)
  sourceConversationId String? // Original conversation
  sourceConversation   Conversation? @relation(fields: [sourceConversationId], references: [id], onDelete: SetNull)

  questionMessageId String? // Reference to original question message
  questionMessage   Message? @relation(name: "FAQQuestionMessage", fields: [questionMessageId], references: [id], onDelete: SetNull)

  answerMessageId String? // Reference to answer message
  answerMessage   Message? @relation(name: "FAQAnswerMessage", fields: [answerMessageId], references: [id], onDelete: SetNull)

  // Publishing details
  teamId String
  team   Team   @relation(fields: [teamId], references: [id], onDelete: Cascade)

  publishedByUserId String
  publishedByUser   User   @relation(fields: [publishedByUserId], references: [id], onDelete: Cascade)

  // Visibility and status
  visibilityMode FaqVisibility @default(PUBLIC_DATAROOM)
  status         FaqStatus     @default(PUBLISHED)
  isAnonymized   Boolean       @default(true)

  // Analytics
  viewCount Int @default(0)

  // Optional categorization
  tags String[] @default([])

  // Metadata
  documentPageNumber    Int? // Optional: specific page reference
  documentVersionNumber Int? // Optional: specific version reference

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([dataroomId])
  @@index([linkId])
  @@index([dataroomDocumentId])
  @@index([sourceConversationId])
  @@index([teamId])
  @@index([publishedByUserId])
  @@index([status])
  @@index([visibilityMode])
  @@index([createdAt])
}

// Define FAQ visibility options
enum FaqVisibility {
  PUBLIC_DATAROOM // Visible to all dataroom visitors
  PUBLIC_LINK // Visible only to specific link visitors
  PUBLIC_DOCUMENT // Visible only when viewing specific document
}

// Define FAQ status
enum FaqStatus {
  DRAFT // Not yet published
  PUBLISHED // Live and visible to visitors
  ARCHIVED // No longer visible but kept for reference
}
model DocumentAnnotation {
  id           String   @id @default(cuid())
  title        String
  content      Json     // Rich text content stored as JSON (Tiptap/ProseMirror format)
  pages        Int[]    // Array of page numbers this annotation applies to
  documentId   String
  document     Document @relation(fields: [documentId], references: [id], onDelete: Cascade)
  teamId       String
  team         Team     @relation(fields: [teamId], references: [id], onDelete: Cascade)
  createdById  String
  createdBy    User     @relation(fields: [createdById], references: [id], onDelete: Cascade)
  isVisible    Boolean  @default(true) // Allow admin to hide/show annotations
  images       AnnotationImage[] // Images attached to this annotation
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  @@index([documentId])
  @@index([teamId])
  @@index([createdById])
}

model AnnotationImage {
  id           String             @id @default(cuid())
  filename     String
  url          String
  size         Int?
  mimeType     String?
  annotationId String
  annotation   DocumentAnnotation @relation(fields: [annotationId], references: [id], onDelete: Cascade)
  createdAt    DateTime           @default(now())

  @@index([annotationId])
}
model Integration {
  id          String   @id @default(cuid())
  name        String
  slug        String   @unique
  description String?
  readme      String?
  developer   String
  website     String
  logo        String?
  screenshots Json?
  verified    Boolean  @default(false)
  installUrl  String?
  category    String?
  comingSoon  Boolean  @default(false)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  installedIntegrations InstalledIntegration[]
}

model InstalledIntegration {
  id            String  @id @default(cuid())
  credentials   Json?
  configuration Json?
  enabled       Boolean @default(true)

  integrationId String
  integration   Integration @relation(fields: [integrationId], references: [id], onDelete: Cascade)
  userId        String? // user who installed the integration
  user          User?       @relation(fields: [userId], references: [id], onDelete: SetNull)
  teamId        String // team where the integration was installed
  team          Team        @relation(fields: [teamId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([teamId, integrationId])
  @@index([teamId])
  @@index([integrationId])
}
